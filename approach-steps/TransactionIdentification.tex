
\noindent \textcolor{blue}{\noindent \emph{Transaction Identification.} The goal here is to identify transactions in execution logs. 
\vspace{.15cm}
\\
\noindent A transaction is a time-ordered set of different services and method calls. Within the identified transactions, we focus on the one who contains more than one service.} Indeed, our goal
being to spot poor designs, a single call hardly provides any
useful information about the underlying architecture.
Next, two call tables of transaction are generated at two different layer: service-level and method-level. Thus, whenever a service's method is invoked, the first table would
only register the fact that the service was active whereas the second one
would provide complete details.  Representing transactions on two levels of granularity
helps improve the performances of our detection methods,
e.g. reducing running time and increasing precision. \textcolor{blue}{Indeed, a first analysis is performed at a high granularity level--services--to identify suspicious services; then a deepen analysis is performed on them one using both tables of transaction. }



%\noindent \emph{Step - 2: Construction of transactions.} The goal
%here is to recreate transactions from the plain text execution
%logs.
%
%At this stage, successive logs need to be split
%into transactions. As a general principle, a transaction starts and ends with an action
%on the target SBS. Such actions could either be user-driven
%(service consumption) or generated by others actions.
%Moreover, we assume that relevant
%transactions cover actions with at least two calls. Indeed, our goal
%being to spot poor designs, a single call hardly provides any
%useful information about the underlying architecture.
%Next, two transaction tables are generated, a service-
%and a method-level one. Thus, whenever a service call
%results in two of its methods being invoked, the first table would
%only register the fact that the service was active whereas the second one
%would provide complete details (see Figure~\ref{fig:Service-level-transactions}
%for examples for both levels).  
%%the first one deals with transactions
%%regardless of methods, although if a service invoke two different
%%methods, the first transaction table, will only have the information
%%that this service has been called. In other hand, the second table
%%will take care of methods.
%Representing transactions on two levels of granularity
%helps improve the performances of our detection methods,
%e.g. reducing running time and increasing precision.
%
%
%%By creating two different tables for the
%%two different layers of abstraction (services and methods) we are
%%able to perform pretreatments to optimize our detection algorithms
%%in term of time and precision. Therefore tables contains information
%%like displayed in , the
%%first line represents the service level and the second line, the method
%%level.
